# let And const

## let
ES6新增了let命令，用来声明变量。  
它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

1. `let`声明的变量只在它所在的代码块有效。
	- for循环的计数器，就很合适使用let命令。
2. `let`不像`var`那样会发生“变量提升”现象。
	- 所以，变量一定要在声明后使用，否则报错。
3. 暂时性死区
	- （temporal dead zone，简称TDZ）
4. 不允许重复声明
	- let不允许在相同作用域内，重复声明同一个变量。
	- 因此，不能在函数内部重新声明参数。



暂时性死区
```js
var tmp = 123;

// ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```

## 块级作用域

#### 为什么需要块级作用域？
ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

1. 内层变量可能会覆盖外层变量。
2. 用来计数的循环变量泄露为全局变量

#### ES6的块级作用域
1. `let`实际上为JavaScript新增了块级作用域。
2. 块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。
3. ES6也规定，函数本身的作用域，在其所在的块级作用域之内

## CONST

1. 一旦声明，常量的值就不能改变。
2. 注意，如果是常规模式，对常量赋值不会报错，但也是无效的。
3. const的作用域与let命令相同：只在声明所在的块级作用域内有效。
4. const命令声明的常量也是不提升，同样存在暂时性死区
5. const声明的常量，也与let一样不可重复声明
6. 对于 __复合类型__ 的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。
7. 如果真的想将对象冻结，应该使用Object.freeze方法。


```js
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

## 声明方法
ES5只有两种声明变量的方法：var命令和function命令。  
ES6除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法： __import__ 命令和 __class__ 命令。所以，
ES6一共有6种声明变量的方法。


## 跨模块常量

?? 未解决
1. node -- import
2. export















- - -
